import { createAsyncThunk, createSlice } from "@reduxjs/toolkit";
import { fetchCart, postCart } from "./cartApi";

const initialState = {
  items: [],
  total: 0,
  discountTotal: 0,
  count: 0,
  loading: false,
};

// The function below is called a thunk and allows us to perform async logic. It
// can be dispatched like a regular action: `dispatch(fetchProducts())`. This
// will call the thunk with the `dispatch` function as the first argument. Async
// code can then be executed and other actions can be dispatched. Thunks are
// typically used to make async requests.

export const getCart = createAsyncThunk(
  "cart/getCart",
  fetchCart // <--- getCart is already an async function so we just pass it here, otherwise we can define it.
  // the reason why getCart is inside another file called cartApi, is because usually fetching from APIs isn't
  // as simple as calling fetch. It usually have other api credentials and configurations and it shouldn't sit with the
  // reducer logic.
);

export const saveCart = createAsyncThunk("cart/saveCart", postCart);

export const cartSlice = createSlice({
  name: "cart",
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    addItem: (state, action) => {
      // Redux Toolkit allows us to write "mutating" logic in reducers. It
      // doesn't actually mutate the state because it uses the Immer library,
      // which detects changes to a "draft state" and produces a brand new
      // immutable state based off those changes
      const amount = action.payload.amount || 1;
      const item = action.payload.item;
      let index = state.items.findIndex((p) => p.id === item.id);
      let inCart = index !== -1;

      for (let i = 0; i < amount; i++) {
        if (!inCart) {
          state.items.push({ ...item, quantity: 1 });
          index = state.items.length - 1;
          inCart = true;
        } else {
          state.items[index].quantity += 1;
        }

        state.total += item.price;
        state.count += 1;
        if (item.hasDiscount) {
          state.discountTotal += item.price - item.discountPrice;
        }
      }
    },
    removeItem: (state, action) => {
      let amount = Math.abs(action.payload.amount) || 1;
      const item = action.payload.item;
      let index = state.items.findIndex((p) => p.id === item.id);
      let quantity = state.items[index].quantity;

      while (quantity > 0 && amount > 0) {
        quantity--;
        amount--;
        state.items[index].quantity -= 1;
        state.total -= item.price;
        state.count -= 1;
        if (item.hasDiscount) {
          state.discountTotal -= item.price - item.discountPrice;
        }
        if (quantity === 0) {
          state.items.splice(index, 1);
        }
      }
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      .addCase(getCart.pending, (state) => {
        state.loading = true;
      })
      .addCase(getCart.fulfilled, (_, action) => {
        // here we return because we can't cay state = action.payload,
        // since we will be changing the reference and not a state item
        // Remember that we are using immer.js, which is a library tha works with drafts
        // and make it easy to mutate drafts, and the lib will create an object
        // but it needs to look like mutating inner property. Assignment of variable won't work
        if (action.payload.items) return { ...action.payload, loading: false };
      });
  },
});

export const { addItem, removeItem } = cartSlice.actions;

export default cartSlice.reducer;
